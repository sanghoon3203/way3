# Way Trading Game - 서버 통신 변환 설계 문서

## 📋 프로젝트 개요

현재 Way Trading Game iOS 앱은 샘플 데이터로 구현된 프로필, 상점, 인벤토리, 퀘스트 기능을 실제 서버와의 API 통신으로 변환하는 프로젝트입니다.

## 🔍 현재 상황 분석

### iOS 앱 구조
```
way3/
├── Core/                    # 핵심 매니저들
│   ├── NetworkManager.swift
│   ├── DataManager.swift
│   ├── AuthManager.swift
│   └── ...
├── Models/                  # 데이터 모델들
│   ├── Player/
│   ├── GameEnums.swift
│   └── ...
├── Components/              # UI 컴포넌트들
│   ├── CyberpunkProfileComponents.swift
│   ├── CyberpunkShopComponents.swift
│   ├── CyberpunkInventoryComponents.swift
│   └── CyberpunkQuestComponents.swift
└── Views/                   # 뷰 파일들
```

### 서버 구조
```
theway_server/
├── src/
│   ├── routes/api/          # API 라우트들
│   │   ├── auth.js
│   │   ├── player.js
│   │   ├── merchants.js
│   │   ├── trade.js
│   │   ├── quests.js
│   │   └── ...
│   ├── database/            # 데이터베이스 관리
│   └── middleware/          # 미들웨어들
└── package.json
```

## 📊 기능별 데이터 구조 분석

### 1. 프로필 (Profile)

#### 현재 iOS 모델
```swift
class PlayerCore: ObservableObject, Codable {
    var id: String
    var name: String
    var level: Int
    var experience: Int
    var money: Int
    var trustPoints: Int
    var reputation: Int
    var currentLicense: LicenseLevel
    // ...
}
```

#### 서버 API 응답 구조
```json
// GET /api/player/profile
{
  "success": true,
  "data": {
    "id": "player_id",
    "name": "플레이어명",
    "level": 15,
    "experience": 12500,
    "money": 850000,
    "trustPoints": 245,
    "reputation": 180,
    "currentLicense": 2,
    "inventory": [...],
    "storageItems": [...],
    "recentTrades": [...]
  }
}
```

### 2. 상점 (Shop)

#### 현재 iOS 모델
```swift
struct SpecialItem {
    let id: UUID
    let name: String
    let description: String
    let grade: ItemGrade
    let specialEffect: String
    let price: Int
    let stock: Int?
    let isLimited: Bool
}
```

#### 서버 API 응답 구조
```json
// GET /api/merchants/nearby?lat=37.5&lng=127.0
{
  "success": true,
  "data": {
    "merchants": [
      {
        "id": "merchant_id",
        "name": "상인명",
        "inventoryCount": 25,
        "location": {"lat": 37.5, "lng": 127.0},
        "canTrade": true
      }
    ]
  }
}

// GET /api/merchants/{merchantId}
{
  "success": true,
  "data": {
    "id": "merchant_id",
    "name": "상인명",
    "inventory": [
      {
        "itemTemplateId": "item_id",
        "name": "아이템명",
        "category": "luxury",
        "grade": 3,
        "currentPrice": 15000,
        "quantity": 5
      }
    ]
  }
}
```

### 3. 인벤토리 (Inventory)

#### 현재 iOS 모델
```swift
struct TradeGood {
    let id: UUID
    let name: String
    let category: String
    let grade: ItemGrade
    let basePrice: Int
    let quantity: Int
}
```

#### 서버 API 응답 구조
```json
// GET /api/player/profile 내 inventory 필드
"inventory": [
  {
    "id": "player_item_id",
    "itemTemplateId": "item_template_id",
    "name": "고급 도자기",
    "category": "ceramic",
    "grade": 2,
    "basePrice": 8500,
    "quantity": 3,
    "purchasePrice": 7200
  }
]
```

### 4. 퀘스트 (Quest)

#### 현재 iOS 모델
```swift
struct Quest {
    let name: String
    let description: String
    let difficulty: QuestDifficulty
    let timeLimit: TimeInterval
    let reward: QuestReward
    let merchantName: String
    let merchantLocation: String
}
```

#### 서버 API 응답 구조
```json
// GET /api/quests/available
{
  "success": true,
  "data": {
    "availableQuests": [
      {
        "id": "quest_id",
        "name": "첫 거래 완료하기",
        "description": "상인과 첫 거래를 완료하세요",
        "category": "tutorial",
        "objectives": [
          {"type": "trade_complete", "count": 1}
        ],
        "rewards": {
          "money": 5000,
          "exp": 100,
          "trust": 10
        },
        "timeLimit": 0
      }
    ]
  }
}
```

## 🔄 API 통신 변환 계획

### 1. NetworkManager 개선

```swift
class NetworkManager: ObservableObject {
    static let shared = NetworkManager()
    private let baseURL = "http://localhost:3000/api"
    private var authToken: String?

    // MARK: - Authentication
    func login(username: String, password: String) async throws -> AuthResponse
    func refreshToken() async throws -> AuthResponse

    // MARK: - Player API
    func fetchPlayerProfile() async throws -> PlayerProfileResponse
    func updatePlayerLocation(lat: Double, lng: Double) async throws
    func increasePlayerStat(statType: String) async throws

    // MARK: - Merchants API
    func fetchNearbyMerchants(lat: Double, lng: Double, radius: Double) async throws -> MerchantsResponse
    func fetchMerchantDetails(merchantId: String) async throws -> MerchantDetailResponse

    // MARK: - Trade API
    func executeTrade(merchantId: String, itemTemplateId: String, tradeType: String, quantity: Int, proposedPrice: Int) async throws -> TradeResponse
    func fetchTradeHistory(page: Int, limit: Int) async throws -> TradeHistoryResponse

    // MARK: - Quests API
    func fetchAvailableQuests() async throws -> QuestsResponse
    func fetchActiveQuests() async throws -> QuestsResponse
    func acceptQuest(questId: String) async throws
    func updateQuestProgress(eventType: String, eventData: [String: Any]) async throws
}
```

### 2. 데이터 매니저 업데이트

```swift
class DataManager: ObservableObject {
    @Published var player: PlayerCore?
    @Published var nearbyMerchants: [Merchant] = []
    @Published var availableQuests: [Quest] = []
    @Published var activeQuests: [Quest] = []

    private let networkManager = NetworkManager.shared

    // MARK: - Player Data
    func loadPlayerProfile() async {
        do {
            let response = try await networkManager.fetchPlayerProfile()
            DispatchQueue.main.async {
                self.player = PlayerCore.from(apiResponse: response.data)
            }
        } catch {
            // Handle error with fallback to sample data
            handleNetworkError(error)
        }
    }

    // MARK: - Merchants Data
    func loadNearbyMerchants(userLocation: CLLocation) async {
        do {
            let response = try await networkManager.fetchNearbyMerchants(
                lat: userLocation.coordinate.latitude,
                lng: userLocation.coordinate.longitude,
                radius: 1000
            )
            DispatchQueue.main.async {
                self.nearbyMerchants = response.data.merchants.map { Merchant.from(apiResponse: $0) }
            }
        } catch {
            handleNetworkError(error)
        }
    }

    // MARK: - Error Handling
    private func handleNetworkError(_ error: Error) {
        // 오프라인 모드 또는 샘플 데이터로 fallback
        print("Network error: \(error)")
        // Load sample data as fallback
    }
}
```

### 3. 모델 확장 (API 응답 변환)

```swift
extension PlayerCore {
    static func from(apiResponse: PlayerProfileData) -> PlayerCore {
        let player = PlayerCore(
            id: apiResponse.id,
            name: apiResponse.name
        )
        player.level = apiResponse.level
        player.experience = apiResponse.experience
        player.money = apiResponse.money
        player.trustPoints = apiResponse.trustPoints
        player.reputation = apiResponse.reputation
        player.currentLicense = LicenseLevel(rawValue: apiResponse.currentLicense) ?? .beginner
        return player
    }

    func toApiRequest() -> [String: Any] {
        return [
            "name": name,
            "level": level,
            "experience": experience,
            "money": money,
            // ...
        ]
    }
}

extension TradeGood {
    static func from(apiResponse: InventoryItem) -> TradeGood {
        return TradeGood(
            id: UUID(uuidString: apiResponse.id) ?? UUID(),
            name: apiResponse.name,
            category: apiResponse.category,
            grade: ItemGrade(rawValue: apiResponse.grade) ?? .common,
            basePrice: apiResponse.basePrice,
            quantity: apiResponse.quantity
        )
    }
}

extension Quest {
    static func from(apiResponse: QuestData) -> Quest {
        let difficulty: QuestDifficulty = .normal // Convert from API
        let reward = QuestReward(
            money: apiResponse.rewards.money ?? 0,
            experience: apiResponse.rewards.exp ?? 0,
            trustPoints: apiResponse.rewards.trust ?? 0
        )

        return Quest(
            id: UUID(uuidString: apiResponse.id) ?? UUID(),
            name: apiResponse.name,
            description: apiResponse.description,
            difficulty: difficulty,
            timeLimit: TimeInterval(apiResponse.timeLimit ?? 0),
            reward: reward,
            merchantName: "API상인", // 추후 merchant 정보 연결
            merchantLocation: "서울"
        )
    }
}
```

## 🚀 구현 단계

### Phase 1: 인증 시스템 구현
1. ✅ 서버 JWT 인증 확인
2. 🔄 iOS AuthManager 업데이트
3. 🔄 자동 토큰 갱신 구현
4. 🔄 로그인/로그아웃 플로우 구현

### Phase 2: 플레이어 프로필 연동
1. 🔄 NetworkManager에 플레이어 API 메서드 추가
2. 🔄 PlayerCore 모델 확장 (API 변환)
3. 🔄 프로필 화면 데이터 로딩 구현
4. 🔄 위치 업데이트 연동

### Phase 3: 상점 시스템 연동
1. 🔄 상인 목록 API 연동
2. 🔄 상인 상세 정보 및 인벤토리 연동
3. 🔄 SpecialItem → Merchant Inventory 변환
4. 🔄 실시간 상인 위치 기반 필터링

### Phase 4: 인벤토리 시스템 연동
1. 🔄 플레이어 인벤토리 API 연동
2. 🔄 TradeGood 모델 API 변환
3. 🔄 인벤토리 UI 업데이트
4. 🔄 아이템 상세 정보 연동

### Phase 5: 퀘스트 시스템 연동
1. 🔄 사용 가능한 퀘스트 API 연동
2. 🔄 진행 중인 퀘스트 API 연동
3. 🔄 퀘스트 수락/포기 기능 구현
4. 🔄 퀘스트 진행도 업데이트 연동

### Phase 6: 거래 시스템 연동
1. 🔄 거래 실행 API 연동
2. 🔄 거래 이력 조회 연동
3. 🔄 시장 가격 정보 연동
4. 🔄 실시간 거래 알림 구현

### Phase 7: 오류 처리 및 최적화
1. 🔄 네트워크 오류 처리
2. 🔄 오프라인 모드 구현
3. 🔄 데이터 캐싱 구현
4. 🔄 성능 최적화

## 📁 주요 파일 수정 목록

### 새로 생성할 파일
- `Core/APIModels.swift` - API 응답 모델들
- `Core/APIService.swift` - API 호출 서비스
- `Utils/NetworkError.swift` - 네트워크 오류 정의

### 수정할 파일
- `Core/NetworkManager.swift` - API 통신 로직 추가
- `Core/DataManager.swift` - 서버 데이터 연동
- `Core/AuthManager.swift` - JWT 인증 구현
- `Models/Player/PlayerCore.swift` - API 변환 메서드 추가
- `Models/GameEnums.swift` - API 호환성 추가
- 모든 Cyberpunk 컴포넌트들 - 실제 데이터 연동

## 🔧 기술적 고려사항

### 1. 네트워크 최적화
- 배치 API 호출로 네트워크 요청 최소화
- 데이터 캐싱으로 반복 요청 방지
- 페이지네이션으로 대용량 데이터 처리

### 2. 오류 처리
- 네트워크 연결 실패 시 샘플 데이터로 fallback
- 토큰 만료 시 자동 갱신
- 사용자 친화적 오류 메시지

### 3. 보안
- JWT 토큰 안전한 저장
- API 키 환경변수 관리
- HTTPS 통신 강제

### 4. 성능
- 비동기 데이터 로딩
- 메모리 효율적인 대용량 리스트 처리
- 백그라운드 데이터 동기화

## 📊 예상 일정

- **Week 1**: Phase 1-2 (인증 + 플레이어 프로필)
- **Week 2**: Phase 3-4 (상점 + 인벤토리)
- **Week 3**: Phase 5-6 (퀘스트 + 거래)
- **Week 4**: Phase 7 (오류 처리 + 최적화)

## ✅ 체크리스트

### 개발 전 준비
- [ ] 서버 개발 환경 설정 확인
- [ ] API 문서화 완료
- [ ] iOS 개발 환경 설정
- [ ] 테스트 계정 생성

### 구현 중 확인사항
- [ ] 각 API 엔드포인트 정상 동작 확인
- [ ] 데이터 변환 로직 테스트
- [ ] UI 업데이트 정상 동작 확인
- [ ] 에러 시나리오 테스트

### 완료 후 검증
- [ ] 모든 기능 정상 동작 확인
- [ ] 성능 최적화 완료
- [ ] 오프라인 모드 테스트
- [ ] 사용자 경험 품질 확인