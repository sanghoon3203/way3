// üìÅ Models/Merchant.swift - Ïò§Î•ò ÏàòÏ†ïÎêú Î≤ÑÏ†Ñ
import Foundation
import CoreLocation
import SwiftUI

struct Merchant: Identifiable {
    let id: String
    
    // Í∏∞Î≥∏ Ï†ïÎ≥¥
    let name: String
    let title: String?
    let type: MerchantType
    let personality: MerchantPersonality
    let district: SeoulDistrict
    let coordinate: CLLocationCoordinate2D
    
    // Í±∞Îûò Í¥ÄÎ†®
    let requiredLicense: LicenseLevel
    var inventory: [TradeItem]
    let priceModifier: Double
    let negotiationDifficulty: Int // 1-5 (1Ïù¥ Ïâ¨ÏõÄ)
    
    // ÏÑ†Ìò∏ÎèÑ ÏãúÏä§ÌÖú
    let preferredItems: [String] // Ïπ¥ÌÖåÍ≥†Î¶¨ Î∞∞Ïó¥
    let dislikedItems: [String]  // Ïπ¥ÌÖåÍ≥†Î¶¨ Î∞∞Ïó¥
    let reputationRequirement: Int
    
    // ÏÉÅÌÉú ÏãúÏä§ÌÖú
    var isActive: Bool
    var lastRestocked: Date

    // Ïù¥ÎØ∏ÏßÄ Ï†ïÎ≥¥
    var imageFileName: String?

    // Í±∞Î¶¨ (Í≥ÑÏÇ∞Îêú Í∞í, ÏòµÏÖîÎÑê)
    var distance: Double = 0.0
    
    // MARK: - Ï¥àÍ∏∞Ìôî
    init(
        id: String = UUID().uuidString,
        name: String,
        title: String? = nil,
        type: MerchantType,
        personality: MerchantPersonality = .calm,
        district: SeoulDistrict,
        coordinate: CLLocationCoordinate2D,
        requiredLicense: LicenseLevel,
        inventory: [TradeItem] = [],
        priceModifier: Double = 1.0,
        negotiationDifficulty: Int = 3,
        preferredItems: [String] = [],
        dislikedItems: [String] = [],
        reputationRequirement: Int = 0,
        isActive: Bool = true,
        imageFileName: String? = nil
    ) {
        self.id = id
        self.name = name
        self.title = title
        self.type = type
        self.personality = personality
        self.district = district
        self.coordinate = coordinate
        self.requiredLicense = requiredLicense
        self.inventory = inventory
        self.priceModifier = priceModifier
        self.negotiationDifficulty = negotiationDifficulty
        self.preferredItems = preferredItems
        self.dislikedItems = dislikedItems
        self.reputationRequirement = reputationRequirement
        self.isActive = isActive
        self.imageFileName = imageFileName
        self.lastRestocked = Date()
    }
    
    // MARK: - ÏÑúÎ≤Ñ ÏùëÎãµÏö© Ï¥àÍ∏∞Ìôî
    init(from serverMerchant: ServerMerchantResponse) {
        self.id = serverMerchant.id
        self.name = serverMerchant.name
        self.title = serverMerchant.title
        self.type = MerchantType(rawValue: serverMerchant.type) ?? .retail
        self.personality = MerchantPersonality(rawValue: serverMerchant.personality) ?? .calm
        self.district = SeoulDistrict(rawValue: serverMerchant.district) ?? .gangnam
        self.coordinate = CLLocationCoordinate2D(
            latitude: serverMerchant.location.lat,
            longitude: serverMerchant.location.lng
        )
        self.requiredLicense = LicenseLevel(rawValue: serverMerchant.requiredLicense) ?? .beginner
        self.inventory = serverMerchant.inventory.map { TradeItem(from: $0) }
        self.priceModifier = serverMerchant.priceModifier
        self.negotiationDifficulty = serverMerchant.negotiationDifficulty
        self.preferredItems = serverMerchant.preferredItems ?? []
        self.dislikedItems = serverMerchant.dislikedItems ?? []
        self.reputationRequirement = serverMerchant.reputationRequirement
        self.isActive = serverMerchant.isActive
        self.imageFileName = serverMerchant.imageFileName
        self.lastRestocked = Date(timeIntervalSince1970: serverMerchant.lastRestocked)
    }
    
    // MARK: - Í≥ÑÏÇ∞Îêú ÏÜçÏÑ±Îì§ (Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥)
    var latitude: Double {
        return coordinate.latitude
    }
    
    var longitude: Double {
        return coordinate.longitude
    }
    
    var pinColor: Color {
        switch type {
        case .retail, .convenience: return .blue
        case .wholesale, .industrial: return .green
        case .premium, .luxury: return .purple
        case .artisan, .craftsman: return .orange
        case .mystic, .collector, .antique: return .red
        case .tech, .electronics: return .cyan
        case .fashion, .artist: return .pink
        case .herbalist, .natural, .forager: return .mint
        case .foodMerchant: return .yellow
        case .scholar: return .indigo
        case .student: return .teal
        case .tourist: return .brown
        }
    }
    
    var iconName: String {
        switch type {
        case .retail: return "cart.fill"
        case .wholesale: return "building.2.fill"
        case .premium: return "crown.fill"
        case .artisan: return "hammer.fill"
        case .mystic: return "sparkles"
        case .collector: return "archivebox.fill"
        case .tech: return "laptopcomputer"
        case .fashion: return "tshirt.fill"
        case .artist: return "paintbrush.fill"
        case .antique: return "scroll.fill"
        case .herbalist: return "leaf.fill"
        case .foodMerchant: return "fork.knife"
        case .industrial: return "gearshape.fill"
        case .luxury: return "gem.fill"
        case .scholar: return "book.fill"
        case .student: return "pencil"
        case .tourist: return "camera.fill"
        case .craftsman: return "wrench.fill"
        case .electronics: return "bolt.fill"
        case .natural: return "tree.fill"
        case .forager: return "basket.fill"
        case .convenience: return "bag.fill"
        }
    }
    
    
    // MARK: - Î©îÏÑúÎìúÎì§
    @MainActor func canTrade(with player: Player) -> Bool {
        // ÎùºÏù¥ÏÑºÏä§ Ï≤¥ÌÅ¨
        guard player.currentLicense.rawValue >= requiredLicense.rawValue else { return false }

        // ÌèâÌåê Ï≤¥ÌÅ¨
        guard player.reputation >= reputationRequirement else { return false }

        // ÌôúÏÑ± ÏÉÅÌÉú Ï≤¥ÌÅ¨
        guard isActive else { return false }

        return true
    }
    
    func getFinalPrice(for item: TradeItem, player: Player) -> Int {
        var finalPrice = Double(item.currentPrice)
        
        // Í∏∞Î≥∏ Í∞ÄÍ≤© ÏàòÏ†ïÏûê Ï†ÅÏö©
        finalPrice *= priceModifier
        
        // ÏÑ†Ìò∏ ÏïÑÏù¥ÌÖú Ìï†Ïù∏
        if preferredItems.contains(item.category) {
            finalPrice *= 0.9 // 10% Ìï†Ïù∏
        }
        
        // ÎπÑÏÑ†Ìò∏ ÏïÑÏù¥ÌÖú Ìï†Ï¶ù
        if dislikedItems.contains(item.category) {
            finalPrice *= 1.2 // 20% Ìï†Ï¶ù
        }
        
        return max(Int(finalPrice), 1) // ÏµúÏÜå 1Ïõê
    }
    
}

// MARK: - Codable Implementation
extension Merchant: Codable {
    enum CodingKeys: String, CodingKey {
        case id, name, title, type, personality, district
        case coordinateLatitude, coordinateLongitude
        case requiredLicense, inventory, priceModifier, negotiationDifficulty
        case preferredItems, dislikedItems, reputationRequirement
        case isActive, lastRestocked, imageFileName, distance
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        id = try container.decode(String.self, forKey: .id)
        name = try container.decode(String.self, forKey: .name)
        title = try container.decodeIfPresent(String.self, forKey: .title)
        type = try container.decode(MerchantType.self, forKey: .type)
        personality = try container.decode(MerchantPersonality.self, forKey: .personality)
        district = try container.decode(SeoulDistrict.self, forKey: .district)
        
        let latitude = try container.decode(Double.self, forKey: .coordinateLatitude)
        let longitude = try container.decode(Double.self, forKey: .coordinateLongitude)
        coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude)
        
        requiredLicense = try container.decode(LicenseLevel.self, forKey: .requiredLicense)
        inventory = try container.decode([TradeItem].self, forKey: .inventory)
        priceModifier = try container.decode(Double.self, forKey: .priceModifier)
        negotiationDifficulty = try container.decode(Int.self, forKey: .negotiationDifficulty)
        preferredItems = try container.decode([String].self, forKey: .preferredItems)
        dislikedItems = try container.decode([String].self, forKey: .dislikedItems)
        reputationRequirement = try container.decode(Int.self, forKey: .reputationRequirement)
        isActive = try container.decode(Bool.self, forKey: .isActive)
        lastRestocked = try container.decode(Date.self, forKey: .lastRestocked)
        imageFileName = try container.decodeIfPresent(String.self, forKey: .imageFileName)
        distance = try container.decodeIfPresent(Double.self, forKey: .distance) ?? 0.0
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encodeIfPresent(title, forKey: .title)
        try container.encode(type, forKey: .type)
        try container.encode(personality, forKey: .personality)
        try container.encode(district, forKey: .district)
        try container.encode(coordinate.latitude, forKey: .coordinateLatitude)
        try container.encode(coordinate.longitude, forKey: .coordinateLongitude)
        try container.encode(requiredLicense, forKey: .requiredLicense)
        try container.encode(inventory, forKey: .inventory)
        try container.encode(priceModifier, forKey: .priceModifier)
        try container.encode(negotiationDifficulty, forKey: .negotiationDifficulty)
        try container.encode(preferredItems, forKey: .preferredItems)
        try container.encode(dislikedItems, forKey: .dislikedItems)
        try container.encode(reputationRequirement, forKey: .reputationRequirement)
        try container.encode(isActive, forKey: .isActive)
        try container.encode(lastRestocked, forKey: .lastRestocked)
        try container.encodeIfPresent(imageFileName, forKey: .imageFileName)
        try container.encode(distance, forKey: .distance)
    }
}

// MARK: - Enums and Supporting Types

// ‚úÖ ÏàòÏ†ïÎêú MerchantType
enum MerchantType: String, CaseIterable, Codable {
    case retail = "retail"           // ÎßêÎã®ÏÉÅÏù∏
    case wholesale = "wholesale"     // Ï§ëÍ∞ÑÏÉÅÏù∏
    case premium = "premium"         // Ï§ëÏöîÎåÄÏÉÅÏù∏
    case artisan = "artisan"         // Ïû•Ïù∏
    case mystic = "mystic"          // Ïã†ÎπÑÏÉÅÏù∏
    case collector = "collector"     // ÏàòÏßëÍ∞Ä
    // ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú ÏÉÅÏù∏ ÌÉÄÏûÖÎì§
    case tech = "tech"               // Í∏∞Ïà†ÏÉÅÏù∏
    case fashion = "fashion"         // Ìå®ÏÖòÏÉÅÏù∏
    case artist = "artist"           // ÏòàÏà†Í∞Ä
    case antique = "antique"         // Í≥®ÎèôÌíàÏÉÅ
    case herbalist = "herbalist"     // ÏïΩÏ¥àÏÉÅ
    case foodMerchant = "food"       // ÏãùÌíàÏÉÅÏù∏
    case industrial = "industrial"   // Í≥µÏóÖÏö©ÌíàÏÉÅ
    case luxury = "luxury"           // Î™ÖÌíàÏÉÅÏù∏
    case scholar = "scholar"         // ÏÑúÏ†ÅÏÉÅÏù∏
    case student = "student"         // ÌïôÏö©ÌíàÏÉÅ
    case tourist = "tourist"         // Í¥ÄÍ¥ëÏÉÅÌíàÏÉÅ
    case craftsman = "craftsman"     // ÏàòÍ≥µÏòàÍ∞Ä
    case electronics = "electronics" // Ï†ÑÏûêÏ†úÌíàÏÉÅ
    case natural = "natural"         // Ï≤úÏó∞Ï†úÌíàÏÉÅ
    case forager = "forager"         // Ï±ÑÏßëÍ∞Ä
    case convenience = "convenience" // ÏùºÏö©ÌíàÏÉÅ
    
    var displayName: String {
        switch self {
        case .retail: return "ÎßêÎã®ÏÉÅÏù∏"
        case .wholesale: return "Ï§ëÍ∞ÑÏÉÅÏù∏"
        case .premium: return "Ï§ëÏöîÏÉÅÏù∏"
        case .artisan: return "Ïû•Ïù∏"
        case .mystic: return "Ïã†ÎπÑÏÉÅÏù∏"
        case .collector: return "ÏàòÏßëÍ∞Ä"
        case .tech: return "Í∏∞Ïà†ÏÉÅÏù∏"
        case .fashion: return "Ìå®ÏÖòÏÉÅÏù∏"
        case .artist: return "ÏòàÏà†Í∞Ä"
        case .antique: return "Í≥®ÎèôÌíàÏÉÅ"
        case .herbalist: return "ÏïΩÏ¥àÏÉÅ"
        case .foodMerchant: return "ÏãùÌíàÏÉÅÏù∏"
        case .industrial: return "Í≥µÏóÖÏö©ÌíàÏÉÅ"
        case .luxury: return "Î™ÖÌíàÏÉÅÏù∏"
        case .scholar: return "ÏÑúÏ†ÅÏÉÅÏù∏"
        case .student: return "ÌïôÏö©ÌíàÏÉÅ"
        case .tourist: return "Í¥ÄÍ¥ëÏÉÅÌíàÏÉÅ"
        case .craftsman: return "ÏàòÍ≥µÏòàÍ∞Ä"
        case .electronics: return "Ï†ÑÏûêÏ†úÌíàÏÉÅ"
        case .natural: return "Ï≤úÏó∞Ï†úÌíàÏÉÅ"
        case .forager: return "Ï±ÑÏßëÍ∞Ä"
        case .convenience: return "ÏùºÏö©ÌíàÏÉÅ"
        }
    }
    
    var maxItemGrade: ItemGrade {
        switch self {
        case .retail: return .intermediate
        case .wholesale: return .rare
        case .premium, .artisan: return .legendary
        case .mystic, .collector: return .legendary
        case .tech, .electronics: return .rare
        case .fashion, .luxury: return .legendary
        case .artist, .antique: return .legendary
        case .herbalist, .natural, .forager: return .rare
        case .foodMerchant: return .intermediate
        case .industrial, .craftsman: return .rare
        case .scholar: return .rare
        case .student, .convenience: return .common
        case .tourist: return .intermediate
        }
    }
}

// ‚úÖ Îã®ÏàúÌôîÎêú MerchantPersonality (ÎßåÎ¶¨ Î¨¥Ïó≠ÏÉÅÏóê ÎßûÍ≤å)
enum MerchantPersonality: String, CaseIterable, Codable {
    case calm = "calm"           // Ïπ®Ï∞©Ìïú
    case shrewd = "shrewd"       // ÏïΩÏÇ≠Îπ†Î•∏
    case generous = "generous"   // Í¥ÄÎåÄÌïú
    case strict = "strict"       // ÍπåÎã§Î°úÏö¥
    // ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú ÏÑ±Í≤© ÌÉÄÏûÖÎì§
    case analytical = "analytical"     // Î∂ÑÏÑùÏ†ÅÏù∏
    case elegant = "elegant"           // Ïö∞ÏïÑÌïú
    case creative = "creative"         // Ï∞ΩÏùòÏ†ÅÏù∏
    case wise = "wise"                 // ÌòÑÎ™ÖÌïú
    case scholarly = "scholarly"       // ÌïôÏûêÏ†ÅÏù∏
    case motherly = "motherly"         // Î™®ÏÑ±Ï†ÅÏù∏
    case practical = "practical"       // Ïã§Ïö©Ï†ÅÏù∏
    case cosmopolitan = "cosmopolitan" // Íµ≠Ï†úÏ†ÅÏù∏
    case intellectual = "intellectual" // ÏßÄÏ†ÅÏù∏
    case energetic = "energetic"       // ÌôúÍ∏∞Ï∞¨
    case sophisticated = "sophisticated" // ÏÑ∏Î†®Îêú
    case friendly = "friendly"         // ÏπúÍ∑ºÌïú
    case meticulous = "meticulous"     // ÍººÍººÌïú
    case techSavvy = "techSavvy"       // Í∏∞Ïà†Ïóê Î∞ùÏùÄ
    case peaceful = "peaceful"         // ÌèâÌôîÎ°úÏö¥
    case rustic = "rustic"             // ÏÜåÎ∞ïÌïú
    
    var personalityDisplayName: String {
        switch self {
        case .calm: return "Ïπ®Ï∞©Ìïú"
        case .shrewd: return "ÏïΩÏÇ≠Îπ†Î•∏"
        case .generous: return "Í¥ÄÎåÄÌïú"
        case .strict: return "ÍπåÎã§Î°úÏö¥"
        case .analytical: return "Î∂ÑÏÑùÏ†ÅÏù∏"
        case .elegant: return "Ïö∞ÏïÑÌïú"
        case .creative: return "Ï∞ΩÏùòÏ†ÅÏù∏"
        case .wise: return "ÌòÑÎ™ÖÌïú"
        case .scholarly: return "ÌïôÏûêÏ†ÅÏù∏"
        case .motherly: return "Î™®ÏÑ±Ï†ÅÏù∏"
        case .practical: return "Ïã§Ïö©Ï†ÅÏù∏"
        case .cosmopolitan: return "Íµ≠Ï†úÏ†ÅÏù∏"
        case .intellectual: return "ÏßÄÏ†ÅÏù∏"
        case .energetic: return "ÌôúÍ∏∞Ï∞¨"
        case .sophisticated: return "ÏÑ∏Î†®Îêú"
        case .friendly: return "ÏπúÍ∑ºÌïú"
        case .meticulous: return "ÍººÍººÌïú"
        case .techSavvy: return "Í∏∞Ïà†Ïóê Î∞ùÏùÄ"
        case .peaceful: return "ÌèâÌôîÎ°úÏö¥"
        case .rustic: return "ÏÜåÎ∞ïÌïú"
        }
    }
}

// MARK: - ÏÑúÎ≤Ñ ÏùëÎãµ Î™®Îç∏Îì§ (LocationData Ï§ëÎ≥µ Ï†úÍ±∞)
struct MerchantLocationData: Codable {
    let lat: Double
    let lng: Double
}

struct ServerMerchantResponse: Codable {
    let id: String
    let name: String
    let title: String?
    let type: String
    let personality: String
    let district: String
    let location: MerchantLocationData
    let requiredLicense: Int
    let inventory: [ServerItemResponse]
    let priceModifier: Double
    let negotiationDifficulty: Int
    let preferredItems: [String]?
    let dislikedItems: [String]?
    let reputationRequirement: Int
    let isActive: Bool
    let lastRestocked: TimeInterval
    let imageFileName: String?
}

// Í∏∞Ï°¥ GameEnums.swiftÏóê Ï†ïÏùòÎêú enumÎì§ÏùÑ ÏÇ¨Ïö©

// Player Î™®Îç∏ÏùÄ Í∏∞Ï°¥ Models/Player.swiftÏóê Ï†ïÏùòÎê®

// TradeItemÍ≥º ServerItemResponseÎäî Í∏∞Ï°¥ ÌååÏùºÏóê Ï†ïÏùòÎê®